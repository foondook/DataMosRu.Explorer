/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.6.0 (NJsonSchema v10.0.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
export class AppsClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * Получение списка приложений
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getList(filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/apps?";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetList(_response);
    });
  }
  processGetList(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfAppListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка приложений
   * @param projection Список полей, включённых в ответ
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListPost(projection, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/apps?";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListPost(_response);
    });
  }
  processGetListPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfAppListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка приложений по идентификатору категории
   * @param categoryId Идентификатор категории
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListByCategory(categoryId, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/categories/{categoryId}/apps?";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByCategory(_response);
    });
  }
  processGetListByCategory(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfAppListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка приложений по идентификатору категории
   * @param categoryId Идентификатор категории
   * @param projection Список полей, включённых в ответ запроса
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListByCategoryPost(
    categoryId,
    projection,
    filter,
    orderby,
    top,
    skip,
    inlinecount
  ) {
    let url_ = this.baseUrl + "/v1/categories/{categoryId}/apps?";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByCategoryPost(_response);
    });
  }
  processGetListByCategoryPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfAppListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение приложения по его идентификатору
   * @param id Идентификатор приложения
   * @return OK
   */
  getItem(id) {
    let url_ = this.baseUrl + "/v1/apps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItem(_response);
    });
  }
  processGetItem(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApplicationItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение приложения по его идентификатору
   * @param id Идентификатор приложения
   * @param projection Список полей, возвращаемыхв ответе запроса
   * @return OK
   */
  getItemPost(id, projection) {
    let url_ = this.baseUrl + "/v1/apps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItemPost(_response);
    });
  }
  processGetItemPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ApplicationItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class CategoriesClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * Получение списка категорий
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getCategoriesList(filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/categories?";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetCategoriesList(_response);
    });
  }
  processGetCategoriesList(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfCategoryListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка категорий
   * @param projection Список полей, включённых в ответ запроса
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getCategoriesListPost(projection, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/categories?";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetCategoriesListPost(_response);
    });
  }
  processGetCategoriesListPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfCategoryListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение информации о категории
   * @param id Идентификатор категории
   * @return OK
   */
  getItem(id) {
    let url_ = this.baseUrl + "/v1/categories/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItem(_response);
    });
  }
  processGetItem(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CategoryItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение информации о категории
   * @param id Идентификатор категории
   * @param projection Список полей, включённых в ответ запроса
   * @return OK
   */
  getItemPost(id, projection) {
    let url_ = this.baseUrl + "/v1/categories/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItemPost(_response);
    });
  }
  processGetItemPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CategoryItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение byte[] иконки категории
   * @param id Идентификатор категории
   * @return OK
   */
  getItemIcon(id) {
    let url_ = this.baseUrl + "/v1/categories/{id}/icon/bytes";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItemIcon(_response);
    });
  }
  processGetItemIcon(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class DatasetsClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * Получение списка наборов данных или справочников
   * @param foreign (optional) Указание язычности наборов данных, true - возвращает англоязычные данные
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getList(foreign, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/datasets?";
    if (foreign !== undefined)
      url_ += "foreign=" + encodeURIComponent("" + foreign) + "&";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetList(_response);
    });
  }
  processGetList(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfDatasetListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка наборов данных или справочников
   * @param projection Список возвращаемых полей в ответе запроса
   * @param foreign (optional) Указание язычности наборов данных, true - возвращает англоязычные данные
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListPost(projection, foreign, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/datasets?";
    if (foreign !== undefined)
      url_ += "foreign=" + encodeURIComponent("" + foreign) + "&";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListPost(_response);
    });
  }
  processGetListPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfDatasetListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка наборов данных или справочников для заданного департамента
   * @param departmentId Идентификатор департамента
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListByDepartment(departmentId, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/departments/{departmentId}/datasets?";
    if (departmentId === undefined || departmentId === null)
      throw new Error("The parameter 'departmentId' must be defined.");
    url_ = url_.replace(
      "{departmentId}",
      encodeURIComponent("" + departmentId)
    );
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDepartment(_response);
    });
  }
  processGetListByDepartment(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfDatasetListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка наборов данных или справочников для заданного департамента
   * @param departmentId Идентификатор департамента
   * @param projection Список возвращаемых полей в ответе запроса
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListByDepartmentPost(
    departmentId,
    projection,
    filter,
    orderby,
    top,
    skip,
    inlinecount
  ) {
    let url_ = this.baseUrl + "/v1/departments/{departmentId}/datasets?";
    if (departmentId === undefined || departmentId === null)
      throw new Error("The parameter 'departmentId' must be defined.");
    url_ = url_.replace(
      "{departmentId}",
      encodeURIComponent("" + departmentId)
    );
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDepartmentPost(_response);
    });
  }
  processGetListByDepartmentPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfDatasetListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка наборов данных или справочников для заданной категории
   * @param categoryId Идентификатор категории
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListByCategory(categoryId, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/categories/{categoryId}/datasets?";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByCategory(_response);
    });
  }
  processGetListByCategory(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfDatasetListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка наборов данных или справочников для заданной категории
   * @param categoryId Идентификатор категории
   * @param projection Список возвращаемых полей в ответе запроса
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getListByCategoryPost(
    categoryId,
    projection,
    filter,
    orderby,
    top,
    skip,
    inlinecount
  ) {
    let url_ = this.baseUrl + "/v1/categories/{categoryId}/datasets?";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByCategoryPost(_response);
    });
  }
  processGetListByCategoryPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение структуры набора данных
   * @param id Идентификатор набора данных
   * @return OK
   */
  getItem(id) {
    let url_ = this.baseUrl + "/v1/datasets/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItem(_response);
    });
  }
  processGetItem(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DatasetItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение структуры набора данных
   * @param id Идентификатор набора данных
   * @param projection Список возвращаемых полей в ответе запроса
   * @return OK
   */
  getItemPost(id, projection) {
    let url_ = this.baseUrl + "/v1/datasets/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItemPost(_response);
    });
  }
  processGetItemPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DatasetItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение актуальной версии набора данных
   * @param datasetId Идентификатор набора данных
   * @return OK
   */
  getVersion(datasetId) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/version";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetVersion(_response);
    });
  }
  processGetVersion(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DatasetVersionItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение иконки датасета
   * @param datasetId Идентификатор набора данных
   * @param size Размер
   * @return OK
   */
  getTransparentIcon(datasetId, size) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/icon/{size}";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (size === undefined || size === null)
      throw new Error("The parameter 'size' must be defined.");
    url_ = url_.replace("{size}", encodeURIComponent("" + size));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "image/png"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetTransparentIcon(_response);
    });
  }
  processGetTransparentIcon(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then(blob => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение маркера карты для набора данных
   * @param datasetId Идентификатор набора данных
   * @return OK
   */
  getMarker(datasetId) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/marker";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/xml"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetMarker(_response);
    });
  }
  processGetMarker(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then(blob => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение цветной иконки набора данных
   * @param datasetId Идентификатор набора данных
   * @param width Размер иконки
   * @param transparent (optional) При значениее true, подложка иконки будет отсутствовать
   * @return OK
   */
  getIcon(datasetId, width, transparent) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/Image/{width}?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (width === undefined || width === null)
      throw new Error("The parameter 'width' must be defined.");
    url_ = url_.replace("{width}", encodeURIComponent("" + width));
    if (transparent !== undefined)
      url_ += "transparent=" + encodeURIComponent("" + transparent) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "image/png"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetIcon(_response);
    });
  }
  processGetIcon(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then(blob => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение изображения набора данных для соц. сетей
   * @param datasetId Идентификатор набора данных
   * @param size (optional) Размер иконки
   * @return OK
   */
  getSocialImage(datasetId, size) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/SocialImage?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (size !== undefined)
      url_ += "size=" + encodeURIComponent("" + size) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "image/png"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetSocialImage(_response);
    });
  }
  processGetSocialImage(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return response.blob().then(blob => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class DepartmentsClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * Получение списка департаментов
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getDepartmentsList(filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/departments?";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetDepartmentsList(_response);
    });
  }
  processGetDepartmentsList(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfDepartmentListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение списка департаментов
   * @param projection Список полей, включённых в ответ запроса
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @param inlinecount (optional) Принимает значение allpages для того, чтобы в ответе получить общее количество записей. По умолчанию общее количество записей не выводится.
   * @return OK
   */
  getDepartmentsListPost(projection, filter, orderby, top, skip, inlinecount) {
    let url_ = this.baseUrl + "/v1/departments?";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    if (inlinecount !== undefined)
      url_ += "$inlinecount=" + encodeURIComponent("" + inlinecount) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetDepartmentsListPost(_response);
    });
  }
  processGetDepartmentsListPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ResultWithCountOfDepartmentListItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение департамента
   * @return OK
   */
  getItem(id) {
    let url_ = this.baseUrl + "/v1/departments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItem(_response);
    });
  }
  processGetItem(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DepartmentItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение департамента
   * @param projection Список полей, включённых в ответ запроса
   * @return OK
   */
  getItemPost(id, projection) {
    let url_ = this.baseUrl + "/v1/departments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItemPost(_response);
    });
  }
  processGetItemPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DepartmentItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class FeaturesClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * Получение строк указанного набора данных в формате GeoJSON
   * @param datasetId Идентификатор набора данных
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param bbox (optional) ограничивающий прямоугольник (bounding box) заданный двумя географическими координатами
   * @return OK
   */
  getListByDatasetId(datasetId, versionNumber, releaseNumber, bbox) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/features?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (bbox !== undefined)
      url_ += "bbox=" + encodeURIComponent("" + bbox) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDatasetId(_response);
    });
  }
  processGetListByDatasetId(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status === 413) {
      return response.text().then(_responseText => {
        return throwException(
          "RequestEntityTooLarge",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение строк указанного набора данных в формате GeoJSON
   * @param datasetId Идентификатор набора данных
   * @param projection Список полей возвращаемых в ответе
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param bbox (optional) ограничивающий прямоугольник (bounding box) заданный двумя географическими координатами
   * @return OK
   */
  getListByDatasetIdPost2(
    datasetId,
    projection,
    versionNumber,
    releaseNumber,
    bbox
  ) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/features?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (bbox !== undefined)
      url_ += "bbox=" + encodeURIComponent("" + bbox) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDatasetIdPost2(_response);
    });
  }
  processGetListByDatasetIdPost2(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status === 413) {
      return response.text().then(_responseText => {
        return throwException(
          "RequestEntityTooLarge",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение строк указанного набора данных в формате GeoJSON
   * @param datasetId Идентификатор набора данных
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param bbox (optional) ограничивающий прямоугольник (bounding box) заданный двумя географическими координатами
   * @return OK
   */
  getListByDatasetId2(datasetId, versionNumber, releaseNumber, bbox) {
    let url_ = this.baseUrl + "/v1/features/{datasetId}?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (bbox !== undefined)
      url_ += "bbox=" + encodeURIComponent("" + bbox) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDatasetId2(_response);
    });
  }
  processGetListByDatasetId2(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status === 413) {
      return response.text().then(_responseText => {
        return throwException(
          "RequestEntityTooLarge",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение строк указанного набора данных в формате GeoJSON
   * @param datasetId Идентификатор набора данных
   * @param projection Список полей возвращаемых в ответе
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param bbox (optional) ограничивающий прямоугольник (bounding box) заданный двумя географическими координатами
   * @return OK
   */
  getListByDatasetIdPost(
    datasetId,
    projection,
    versionNumber,
    releaseNumber,
    bbox
  ) {
    let url_ = this.baseUrl + "/v1/features/{datasetId}?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (bbox !== undefined)
      url_ += "bbox=" + encodeURIComponent("" + bbox) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDatasetIdPost(_response);
    });
  }
  processGetListByDatasetIdPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status === 413) {
      return response.text().then(_responseText => {
        return throwException(
          "RequestEntityTooLarge",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение строк указанного набора данных в формате GeoJSON
   * @param datasetId Идентификатор набора данных
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param rowId (optional) Идентиифкатор строки
   * @param fields (optional) Возвращаемые поля
   * @param bbox (optional) Ограничивающий прямоугольник (bounding box) заданный двумя географическими координатами
   * @return OK
   */
  getMapFeaturesByDatasetId(
    datasetId,
    versionNumber,
    releaseNumber,
    rowId,
    fields,
    bbox
  ) {
    let url_ = this.baseUrl + "/v1/mapfeatures/{datasetId}?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (rowId !== undefined)
      url_ += "rowId=" + encodeURIComponent("" + rowId) + "&";
    if (fields !== undefined)
      fields &&
        fields.forEach(item => {
          url_ += "fields=" + encodeURIComponent("" + item) + "&";
        });
    if (bbox !== undefined)
      url_ += "bbox=" + encodeURIComponent("" + bbox) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetMapFeaturesByDatasetId(_response);
    });
  }
  processGetMapFeaturesByDatasetId(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение строк указанного набора данных в формате GeoJSON
   * @param datasetId Идентификатор набора данных
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param rowId (optional) Идентиифкатор строки
   * @param fields (optional) Возвращаемые поля
   * @param bbox (optional) Ограничивающий прямоугольник (bounding box) заданный двумя географическими координатами
   * @return OK
   */
  getMapFeaturesByDatasetId2(
    datasetId,
    versionNumber,
    releaseNumber,
    rowId,
    fields,
    bbox
  ) {
    let url_ = this.baseUrl + "/v1/mapfeatures/{datasetId}/typedFiltered?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (rowId !== undefined)
      url_ += "rowId=" + encodeURIComponent("" + rowId) + "&";
    if (fields !== undefined)
      fields &&
        fields.forEach(item => {
          url_ += "fields=" + encodeURIComponent("" + item) + "&";
        });
    if (bbox !== undefined)
      url_ += "bbox=" + encodeURIComponent("" + bbox) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetMapFeaturesByDatasetId2(_response);
    });
  }
  processGetMapFeaturesByDatasetId2(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * @param versionNumber (optional)
   * @param releaseNumber (optional)
   * @return OK
   */
  getMapRegionsByDatasetId(datasetId, versionNumber, releaseNumber) {
    let url_ = this.baseUrl + "/v1/map/{datasetId}/regions?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetMapRegionsByDatasetId(_response);
    });
  }
  processGetMapRegionsByDatasetId(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * @param versionNumber (optional)
   * @param releaseNumber (optional)
   * @return OK
   */
  getMapDistrictsByDatasetId(datasetId, versionNumber, releaseNumber) {
    let url_ = this.baseUrl + "/v1/map/{datasetId}/districts?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetMapDistrictsByDatasetId(_response);
    });
  }
  processGetMapDistrictsByDatasetId(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FeatureCollection.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class RowsClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * @param versionNumber (optional) Номер версии набора данных
   * @param releaseNumber (optional) Номер релиза версии
   * @return OK
   */
  getRowsCountByDatasetId(datasetId, versionNumber, releaseNumber) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/count?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetRowsCountByDatasetId(_response);
    });
  }
  processGetRowsCountByDatasetId(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * @param q (optional) Строка поиска
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @return OK
   */
  getListByDatasetId(
    datasetId,
    projection,
    q,
    versionNumber,
    releaseNumber,
    filter,
    orderby,
    top,
    skip
  ) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/rows?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (projection === undefined || projection === null)
      throw new Error(
        "The parameter 'projection' must be defined and cannot be null."
      );
    else
      projection &&
        projection.forEach(item => {
          url_ += "projection=" + encodeURIComponent("" + item) + "&";
        });
    if (q !== undefined) url_ += "q=" + encodeURIComponent("" + q) + "&";
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDatasetId(_response);
    });
  }
  processGetListByDatasetId(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ExampleRowItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * @param q (optional) Строка поиска
   * @param versionNumber (optional) Номер версии
   * @param releaseNumber (optional) Номер релиза
   * @param filter (optional) Фильтрация результате на условии истинности выражения. Поддерживает операторы протокола OData v2.0
   * @param orderby (optional) Указывает поле для сортировки результирующего списка. Пример: $orderby = "Caption", $orderby = "Number desc."
   * @param top (optional) Ограничивает количество возвращаемых записей. Без указания данного параметра выводятся все записи.
   * @param skip (optional) Позволяет указать количество записей, которые следует пропустить в ответе.
   * @return OK
   */
  getListByDatasetIdPost(
    datasetId,
    projection,
    q,
    versionNumber,
    releaseNumber,
    filter,
    orderby,
    top,
    skip
  ) {
    let url_ = this.baseUrl + "/v1/datasets/{datasetId}/rows?";
    if (datasetId === undefined || datasetId === null)
      throw new Error("The parameter 'datasetId' must be defined.");
    url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId));
    if (q !== undefined) url_ += "q=" + encodeURIComponent("" + q) + "&";
    if (versionNumber !== undefined)
      url_ += "versionNumber=" + encodeURIComponent("" + versionNumber) + "&";
    if (releaseNumber !== undefined)
      url_ += "releaseNumber=" + encodeURIComponent("" + releaseNumber) + "&";
    if (filter !== undefined)
      url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
    if (orderby !== undefined)
      url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
    if (top !== undefined) url_ += "$top=" + encodeURIComponent("" + top) + "&";
    if (skip !== undefined)
      url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
    url_ = url_.replace(/[?&]$/, "");
    const content_ = JSON.stringify(projection);
    let options_ = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetListByDatasetIdPost(_response);
    });
  }
  processGetListByDatasetIdPost(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [];
          for (let item of resultData200)
            result200.push(ExampleRowItem.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class StructureClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * Json структура версии набора данных
   * @param id Идентификатор набора данных
   * @param versionNumber Номер версии
   * @param vsDate Дата публикации версии
   * @return OK
   */
  getItem(id, versionNumber, vsDate) {
    let url_ =
      this.baseUrl +
      "/v1/datasets/{id}/structure-{vsDate}(vs{versionNumber}).json";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (versionNumber === undefined || versionNumber === null)
      throw new Error("The parameter 'versionNumber' must be defined.");
    url_ = url_.replace(
      "{versionNumber}",
      encodeURIComponent("" + versionNumber)
    );
    if (vsDate === undefined || vsDate === null)
      throw new Error("The parameter 'vsDate' must be defined.");
    url_ = url_.replace("{vsDate}", encodeURIComponent("" + vsDate));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetItem(_response);
    });
  }
  processGetItem(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DatasetItem.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Json-паспорт набора данных
   * @param id Идентификатор набора данных
   * @return OK
   */
  getPassport(id) {
    let url_ = this.baseUrl + "/v1/datasets/{id}/meta.json";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetPassport(_response);
    });
  }
  processGetPassport(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DatasetPassportData.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class VersionsClient {
  constructor(baseUrl, http) {
    this.jsonParseReviver = undefined;
    this.http = http ? http : window;
    this.baseUrl = baseUrl ? baseUrl : "https://apidata.mos.ru";
  }
  /**
   * Получение актуальной версии API портала
   * @return OK
   */
  get() {
    let url_ = this.baseUrl + "/version";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGet(_response);
    });
  }
  processGet(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = VersionInfo.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
  /**
   * Получение информации о версии
   * @return OK
   */
  getVersion() {
    let url_ = this.baseUrl + "/v1";
    url_ = url_.replace(/[?&]$/, "");
    let options_ = {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    };
    return this.http.fetch(url_, options_).then(_response => {
      return this.processGetVersion(_response);
    });
  }
  processGetVersion(response) {
    const status = response.status;
    let _headers = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200 = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve(null);
  }
}
export class ResultWithCountOfAppListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      if (Array.isArray(_data["Items"])) {
        this.items = [];
        for (let item of _data["Items"])
          this.items.push(AppListItem.fromJS(item));
      }
      this.count = _data["Count"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ResultWithCountOfAppListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["Items"] = [];
      for (let item of this.items) data["Items"].push(item.toJSON());
    }
    data["Count"] = this.count;
    return data;
  }
}
export class AppListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.caption = _data["Caption"];
      this.description = _data["Description"];
      this.categoryId = _data["CategoryId"];
      this.publishDate = _data["PublishDate"];
      this.developer = _data["Developer"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new AppListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Caption"] = this.caption;
    data["Description"] = this.description;
    data["CategoryId"] = this.categoryId;
    data["PublishDate"] = this.publishDate;
    data["Developer"] = this.developer;
    return data;
  }
}
export class AppRequestExample {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {}
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new AppRequestExample();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}
export class ApplicationItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.caption = _data["Caption"];
      this.description = _data["Description"];
      this.categoryId = _data["CategoryId"];
      this.publishDate = _data["PublishDate"];
      this.developer = _data["Developer"];
      this.icon = _data["Icon"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Caption"] = this.caption;
    data["Description"] = this.description;
    data["CategoryId"] = this.categoryId;
    data["PublishDate"] = this.publishDate;
    data["Developer"] = this.developer;
    data["Icon"] = this.icon;
    return data;
  }
}
export class ResultWithCountOfCategoryListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      if (Array.isArray(_data["Items"])) {
        this.items = [];
        for (let item of _data["Items"])
          this.items.push(CategoryListItem.fromJS(item));
      }
      this.count = _data["Count"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ResultWithCountOfCategoryListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["Items"] = [];
      for (let item of this.items) data["Items"].push(item.toJSON());
    }
    data["Count"] = this.count;
    return data;
  }
}
export class CategoryListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.name = _data["Name"];
      this.englishName = _data["EnglishName"];
      this.description = _data["Description"];
      this.englishDescription = _data["EnglishDescription"];
      if (Array.isArray(_data["Datasets"])) {
        this.datasets = [];
        for (let item of _data["Datasets"]) this.datasets.push(item);
      }
      if (Array.isArray(_data["Services"])) {
        this.services = [];
        for (let item of _data["Services"]) this.services.push(item);
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new CategoryListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Name"] = this.name;
    data["EnglishName"] = this.englishName;
    data["Description"] = this.description;
    data["EnglishDescription"] = this.englishDescription;
    if (Array.isArray(this.datasets)) {
      data["Datasets"] = [];
      for (let item of this.datasets) data["Datasets"].push(item);
    }
    if (Array.isArray(this.services)) {
      data["Services"] = [];
      for (let item of this.services) data["Services"].push(item);
    }
    return data;
  }
}
export class CategoryItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.name = _data["Name"];
      this.englishName = _data["EnglishName"];
      this.description = _data["Description"];
      this.icon = _data["Icon"];
      this.englishDescription = _data["EnglishDescription"];
      if (Array.isArray(_data["Datasets"])) {
        this.datasets = [];
        for (let item of _data["Datasets"]) this.datasets.push(item);
      }
      if (Array.isArray(_data["Services"])) {
        this.services = [];
        for (let item of _data["Services"]) this.services.push(item);
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new CategoryItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Name"] = this.name;
    data["EnglishName"] = this.englishName;
    data["Description"] = this.description;
    data["Icon"] = this.icon;
    data["EnglishDescription"] = this.englishDescription;
    if (Array.isArray(this.datasets)) {
      data["Datasets"] = [];
      for (let item of this.datasets) data["Datasets"].push(item);
    }
    if (Array.isArray(this.services)) {
      data["Services"] = [];
      for (let item of this.services) data["Services"].push(item);
    }
    return data;
  }
}
export class ResultWithCountOfDatasetListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      if (Array.isArray(_data["Items"])) {
        this.items = [];
        for (let item of _data["Items"])
          this.items.push(DatasetListItem.fromJS(item));
      }
      this.count = _data["Count"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ResultWithCountOfDatasetListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["Items"] = [];
      for (let item of this.items) data["Items"].push(item.toJSON());
    }
    data["Count"] = this.count;
    return data;
  }
}
export class DatasetListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.versionNumber = _data["VersionNumber"];
      this.releaseNumber = _data["ReleaseNumber"];
      this.caption = _data["Caption"];
      this.categoryId = _data["CategoryId"];
      this.departmentId = _data["DepartmentId"];
      this.publishDate = _data["PublishDate"];
      this.fullDescription = _data["FullDescription"];
      this.keywords = _data["Keywords"];
      this.containsGeodata = _data["ContainsGeodata"];
      this.containsAccEnvData = _data["ContainsAccEnvData"];
      this.isForeign = _data["IsForeign"];
      this.isSeasonal = _data["IsSeasonal"];
      this.season = _data["Season"];
      this.isArchive = _data["IsArchive"];
      this.isNew = _data["IsNew"];
      this.lastUpdateDate = _data["LastUpdateDate"];
      this.sefUrl = _data["SefUrl"];
      this.identificationNumber = _data["IdentificationNumber"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new DatasetListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["VersionNumber"] = this.versionNumber;
    data["ReleaseNumber"] = this.releaseNumber;
    data["Caption"] = this.caption;
    data["CategoryId"] = this.categoryId;
    data["DepartmentId"] = this.departmentId;
    data["PublishDate"] = this.publishDate;
    data["FullDescription"] = this.fullDescription;
    data["Keywords"] = this.keywords;
    data["ContainsGeodata"] = this.containsGeodata;
    data["ContainsAccEnvData"] = this.containsAccEnvData;
    data["IsForeign"] = this.isForeign;
    data["IsSeasonal"] = this.isSeasonal;
    data["Season"] = this.season;
    data["IsArchive"] = this.isArchive;
    data["IsNew"] = this.isNew;
    data["LastUpdateDate"] = this.lastUpdateDate;
    data["SefUrl"] = this.sefUrl;
    data["IdentificationNumber"] = this.identificationNumber;
    return data;
  }
}
export class DatasetItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.identificationNumber = _data["IdentificationNumber"];
      this.categoryId = _data["CategoryId"];
      this.categoryCaption = _data["CategoryCaption"];
      this.departmentId = _data["DepartmentId"];
      this.departmentCaption = _data["DepartmentCaption"];
      this.caption = _data["Caption"];
      this.description = _data["Description"];
      this.fullDescription = _data["FullDescription"];
      this.keywords = _data["Keywords"];
      this.containsGeodata = _data["ContainsGeodata"];
      this.versionNumber = _data["VersionNumber"];
      this.versionDate = _data["VersionDate"];
      this.itemsCount = _data["ItemsCount"];
      if (Array.isArray(_data["Columns"])) {
        this.columns = [];
        for (let item of _data["Columns"])
          this.columns.push(ColumnItem.fromJS(item));
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new DatasetItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["IdentificationNumber"] = this.identificationNumber;
    data["CategoryId"] = this.categoryId;
    data["CategoryCaption"] = this.categoryCaption;
    data["DepartmentId"] = this.departmentId;
    data["DepartmentCaption"] = this.departmentCaption;
    data["Caption"] = this.caption;
    data["Description"] = this.description;
    data["FullDescription"] = this.fullDescription;
    data["Keywords"] = this.keywords;
    data["ContainsGeodata"] = this.containsGeodata;
    data["VersionNumber"] = this.versionNumber;
    data["VersionDate"] = this.versionDate;
    data["ItemsCount"] = this.itemsCount;
    if (Array.isArray(this.columns)) {
      data["Columns"] = [];
      for (let item of this.columns) data["Columns"].push(item.toJSON());
    }
    return data;
  }
}
export class ColumnItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.name = _data["Name"];
      this.caption = _data["Caption"];
      this.visible = _data["Visible"];
      this.type = _data["Type"];
      if (Array.isArray(_data["SubColumns"])) {
        this.subColumns = [];
        for (let item of _data["SubColumns"])
          this.subColumns.push(ColumnItem.fromJS(item));
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ColumnItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Name"] = this.name;
    data["Caption"] = this.caption;
    data["Visible"] = this.visible;
    data["Type"] = this.type;
    if (Array.isArray(this.subColumns)) {
      data["SubColumns"] = [];
      for (let item of this.subColumns) data["SubColumns"].push(item.toJSON());
    }
    return data;
  }
}
/** Актуальные номера версии и релиза набора данных */
export class DatasetVersionItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.versionNumber = _data["versionNumber"];
      this.releaseNumber = _data["releaseNumber"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new DatasetVersionItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["versionNumber"] = this.versionNumber;
    data["releaseNumber"] = this.releaseNumber;
    return data;
  }
}
export class ResultWithCountOfDepartmentListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      if (Array.isArray(_data["Items"])) {
        this.items = [];
        for (let item of _data["Items"])
          this.items.push(DepartmentListItem.fromJS(item));
      }
      this.count = _data["Count"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ResultWithCountOfDepartmentListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["Items"] = [];
      for (let item of this.items) data["Items"].push(item.toJSON());
    }
    data["Count"] = this.count;
    return data;
  }
}
export class DepartmentListItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.name = _data["Name"];
      this.description = _data["Description"];
      this.websiteUrl = _data["WebsiteUrl"];
      this.shortName = _data["ShortName"];
      this.englishName = _data["EnglishName"];
      this.englishDescription = _data["EnglishDescription"];
      this.iNN = _data["INN"];
      if (Array.isArray(_data["Datasets"])) {
        this.datasets = [];
        for (let item of _data["Datasets"]) this.datasets.push(item);
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new DepartmentListItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Name"] = this.name;
    data["Description"] = this.description;
    data["WebsiteUrl"] = this.websiteUrl;
    data["ShortName"] = this.shortName;
    data["EnglishName"] = this.englishName;
    data["EnglishDescription"] = this.englishDescription;
    data["INN"] = this.iNN;
    if (Array.isArray(this.datasets)) {
      data["Datasets"] = [];
      for (let item of this.datasets) data["Datasets"].push(item);
    }
    return data;
  }
}
export class DepartmentItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.name = _data["Name"];
      this.description = _data["Description"];
      this.websiteUrl = _data["WebsiteUrl"];
      this.shortName = _data["ShortName"];
      this.englishName = _data["EnglishName"];
      this.englishDescription = _data["EnglishDescription"];
      this.iNN = _data["INN"];
      if (Array.isArray(_data["Datasets"])) {
        this.datasets = [];
        for (let item of _data["Datasets"]) this.datasets.push(item);
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new DepartmentItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Name"] = this.name;
    data["Description"] = this.description;
    data["WebsiteUrl"] = this.websiteUrl;
    data["ShortName"] = this.shortName;
    data["EnglishName"] = this.englishName;
    data["EnglishDescription"] = this.englishDescription;
    data["INN"] = this.iNN;
    if (Array.isArray(this.datasets)) {
      data["Datasets"] = [];
      for (let item of this.datasets) data["Datasets"].push(item);
    }
    return data;
  }
}
export class FeatureCollection {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      if (Array.isArray(_data["features"])) {
        this.features = [];
        for (let item of _data["features"])
          this.features.push(Feature.fromJS(item));
      }
      if (Array.isArray(_data["bbox"])) {
        this.bbox = [];
        for (let item of _data["bbox"]) this.bbox.push(item);
      }
      this.crs = _data["crs"] ? ICRSObject.fromJS(_data["crs"]) : undefined;
      this.type = _data["type"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new FeatureCollection();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.features)) {
      data["features"] = [];
      for (let item of this.features) data["features"].push(item.toJSON());
    }
    if (Array.isArray(this.bbox)) {
      data["bbox"] = [];
      for (let item of this.bbox) data["bbox"].push(item);
    }
    data["crs"] = this.crs ? this.crs.toJSON() : undefined;
    data["type"] = this.type;
    return data;
  }
}
export class Feature {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.geometry = _data["geometry"]
        ? IGeometryObject.fromJS(_data["geometry"])
        : undefined;
      this.id = _data["id"];
      if (_data["properties"]) {
        this.properties = {};
        for (let key in _data["properties"]) {
          if (_data["properties"].hasOwnProperty(key))
            this.properties[key] = _data["properties"][key];
        }
      }
      if (Array.isArray(_data["bbox"])) {
        this.bbox = [];
        for (let item of _data["bbox"]) this.bbox.push(item);
      }
      this.crs = _data["crs"] ? ICRSObject.fromJS(_data["crs"]) : undefined;
      this.type = _data["type"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new Feature();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["geometry"] = this.geometry ? this.geometry.toJSON() : undefined;
    data["id"] = this.id;
    if (this.properties) {
      data["properties"] = {};
      for (let key in this.properties) {
        if (this.properties.hasOwnProperty(key))
          data["properties"][key] = this.properties[key];
      }
    }
    if (Array.isArray(this.bbox)) {
      data["bbox"] = [];
      for (let item of this.bbox) data["bbox"].push(item);
    }
    data["crs"] = this.crs ? this.crs.toJSON() : undefined;
    data["type"] = this.type;
    return data;
  }
}
export class ICRSObject {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.type = _data["Type"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ICRSObject();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Type"] = this.type;
    return data;
  }
}
export class IGeometryObject {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.type = _data["Type"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new IGeometryObject();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Type"] = this.type;
    return data;
  }
}
export class ExampleRowItem {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["Id"];
      this.global_id = _data["global_id"];
      this.number = _data["Number"];
      this.cells = _data["Cells"];
      this.lat = _data["Lat"];
      this.lon = _data["Lon"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ExampleRowItem();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["global_id"] = this.global_id;
    data["Number"] = this.number;
    data["Cells"] = this.cells;
    data["Lat"] = this.lat;
    data["Lon"] = this.lon;
    return data;
  }
}
export class DatasetPassportData {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.standardversion = _data["Standardversion"];
      this.id = _data["Id"];
      this.identifier = _data["Identifier"];
      this.title = _data["Title"];
      this.description = _data["Description"];
      this.categoryId = _data["CategoryId"];
      this.categoryCaption = _data["CategoryCaption"];
      this.creatorId = _data["CreatorId"];
      this.creator = _data["Creator"];
      this.format = _data["Format"];
      this.versionNumber = _data["VersionNumber"];
      this.valid = _data["Valid"];
      this.modified = _data["Modified"];
      this.provenance = _data["Provenance"];
      this.provenanceEng = _data["ProvenanceEng"];
      if (Array.isArray(_data["Subject"])) {
        this.subject = [];
        for (let item of _data["Subject"]) this.subject.push(item);
      }
      this.structure = _data["Structure"];
      this.publisher = _data["Publisher"];
      this.created = _data["Created"];
      if (Array.isArray(_data["Data"])) {
        this.data = [];
        for (let item of _data["Data"])
          this.data.push(VersionPassportData.fromJS(item));
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new DatasetPassportData();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Standardversion"] = this.standardversion;
    data["Id"] = this.id;
    data["Identifier"] = this.identifier;
    data["Title"] = this.title;
    data["Description"] = this.description;
    data["CategoryId"] = this.categoryId;
    data["CategoryCaption"] = this.categoryCaption;
    data["CreatorId"] = this.creatorId;
    data["Creator"] = this.creator;
    data["Format"] = this.format;
    data["VersionNumber"] = this.versionNumber;
    data["Valid"] = this.valid;
    data["Modified"] = this.modified;
    data["Provenance"] = this.provenance;
    data["ProvenanceEng"] = this.provenanceEng;
    if (Array.isArray(this.subject)) {
      data["Subject"] = [];
      for (let item of this.subject) data["Subject"].push(item);
    }
    data["Structure"] = this.structure;
    data["Publisher"] = this.publisher;
    data["Created"] = this.created;
    if (Array.isArray(this.data)) {
      data["Data"] = [];
      for (let item of this.data) data["Data"].push(item.toJSON());
    }
    return data;
  }
}
export class VersionPassportData {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.versionNumber = _data["VersionNumber"];
      this.releaseNumber = _data["ReleaseNumber"];
      this.source = _data["Source"];
      this.created = _data["Created"];
      this.provenance = _data["Provenance"];
      this.valid = _data["Valid"];
      this.structure = _data["Structure"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new VersionPassportData();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["VersionNumber"] = this.versionNumber;
    data["ReleaseNumber"] = this.releaseNumber;
    data["Source"] = this.source;
    data["Created"] = this.created;
    data["Provenance"] = this.provenance;
    data["Valid"] = this.valid;
    data["Structure"] = this.structure;
    return data;
  }
}
export class VersionInfo {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.version = _data["Version"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new VersionInfo();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["Version"] = this.version;
    return data;
  }
}
export var FeatureCollectionType;
(function(FeatureCollectionType) {
  FeatureCollectionType["Point"] = "Point";
  FeatureCollectionType["MultiPoint"] = "MultiPoint";
  FeatureCollectionType["LineString"] = "LineString";
  FeatureCollectionType["MultiLineString"] = "MultiLineString";
  FeatureCollectionType["Polygon"] = "Polygon";
  FeatureCollectionType["MultiPolygon"] = "MultiPolygon";
  FeatureCollectionType["GeometryCollection"] = "GeometryCollection";
  FeatureCollectionType["Feature"] = "Feature";
  FeatureCollectionType["FeatureCollection"] = "FeatureCollection";
})(FeatureCollectionType || (FeatureCollectionType = {}));
export var FeatureType;
(function(FeatureType) {
  FeatureType["Point"] = "Point";
  FeatureType["MultiPoint"] = "MultiPoint";
  FeatureType["LineString"] = "LineString";
  FeatureType["MultiLineString"] = "MultiLineString";
  FeatureType["Polygon"] = "Polygon";
  FeatureType["MultiPolygon"] = "MultiPolygon";
  FeatureType["GeometryCollection"] = "GeometryCollection";
  FeatureType["Feature"] = "Feature";
  FeatureType["FeatureCollection"] = "FeatureCollection";
})(FeatureType || (FeatureType = {}));
export var ICRSObjectType;
(function(ICRSObjectType) {
  ICRSObjectType["Unspecified"] = "Unspecified";
  ICRSObjectType["Name"] = "Name";
  ICRSObjectType["Link"] = "Link";
})(ICRSObjectType || (ICRSObjectType = {}));
export var IGeometryObjectType;
(function(IGeometryObjectType) {
  IGeometryObjectType["Point"] = "Point";
  IGeometryObjectType["MultiPoint"] = "MultiPoint";
  IGeometryObjectType["LineString"] = "LineString";
  IGeometryObjectType["MultiLineString"] = "MultiLineString";
  IGeometryObjectType["Polygon"] = "Polygon";
  IGeometryObjectType["MultiPolygon"] = "MultiPolygon";
  IGeometryObjectType["GeometryCollection"] = "GeometryCollection";
  IGeometryObjectType["Feature"] = "Feature";
  IGeometryObjectType["FeatureCollection"] = "FeatureCollection";
})(IGeometryObjectType || (IGeometryObjectType = {}));
export class ApiException extends Error {
  constructor(message, status, response, headers, result) {
    super();
    this.isApiException = true;
    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }
  static isApiException(obj) {
    return obj.isApiException === true;
  }
}
function throwException(message, status, response, headers, result) {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
